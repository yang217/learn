<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<script type="text/javascript">
// var person = {
//     name: 'TOM',
//     age: '20',
   
// }
// ["name","age"].forEach(function(item){
// 	console.log(person[item])
// })
// ['name', 'age'].forEach(function(item) {
//     console.log(person[item]);
// })
var creatperson=function(name,age){
	var o=new Object();
	o.name=name;
	o.age=age;
	return o
}
console.log(creatperson("zhang","22"));

// 先一本正经的创建一个构造函数，其实该函数与普通函数并无区别
var Person = function(name, age) {
    this.name = name;
    this.age = age;
    this.getName = function() {
        return this.name;
    }
}

// 将构造函数以参数形式传入
function New(func) {

    // 声明一个中间对象，该对象为最终返回的实例
    var res = {};
    if (func.prototype !== null) {

        // 将实例的原型指向构造函数的原型
        res.__proto__ = func.prototype;
    }

    // ret为构造函数执行的结果，这里通过apply，将构造函数内部的this指向修改为指向res，即为实例对象
    var ret = func.apply(res, Array.prototype.slice.call(arguments, 1));

    // 当我们在构造函数中明确指定了返回对象时，那么new的执行结果就是该返回对象
    if ((typeof ret === "object" || typeof ret === "function") && ret !== null) {
        return ret;
    }

    // 如果没有明确指定返回对象，则默认返回res，这个res就是实例对象
    return res;
}

// 通过new声明创建实例，这里的p1，实际接收的正是new中返回的res
var p1 = New(Person, 'tom', 20);
console.log(p1.getName());

// 当然，这里也可以判断出实例的类型了
console.log(p1 instanceof Person); // true






// 关于arguments
 var a={length:2,0:'first',1:'second'};
 Array.prototype.slice.call(a);//  ["first", "second"]
  
 var a={length:2};
 Array.prototype.slice.call(a);//  [undefined, undefined]
 var b=function(j,q,b){

 }
 	console.log(Array.prototype.slice.call(b,1),"哈哈");

 	var toArray = function(s){
    try{
        return Array.prototype.slice.call(s);
    } catch(e){
            var arr = [];
            for(var i = 0,len = s.length; i < len; i++){
                //arr.push(s[i]);
                   arr[i] = s[i];  //据说这样比push快
            }
             return arr;
    }
}
  
</script>

</body>
</html>